/**********************************************************************************  
** Program name:	Rogue-like Survival	 			- Final Project -
** Author:  		Brian Tsui
** Date:  			06/12/2017
** Description: 	This is the Implementation code for main game class.
					This class sets the gameflow and handles some logical mechanics.

					This game design is inspired by one of the tutorial demo projects for Unity3D.
					https://unity3d.com/learn/tutorials/s/2d-roguelike-tutorial
					
					The game takes in W A S D and 1 2 3 4 input to control.
					Move around the 2D map to collect item and get to the Goal.
					Available actions are dynamically responsive to surrounding blocks.
					Every step loses health, and zombies will chase you down.
					Every level's map is randomly generated (with some rules).
					Health points and inventory items are carried down to next level.
					Try to survive as many levels as possible.
					
					A graphical instruction manual is displayed at the beginning.
					
					Most display messages are in Displayer class.
					Every level is randomly generated by Mapper class.
					The 2D map is an abstract utilizing ListNode (from lab 6).
					GameObjs defines game object as structs. 
										
**********************************************************************************/

#include "Game.hpp"
#include <iostream>
#include <string>

using namespace std;


/****************************
*							*
*	Default Constructor		*
*							*
****************************/

Game::Game(int d)
{
	dimension = d;							// dimension of the map
	level = 0;								// level is the score counter of the game
	playerHP = 100;							// Player's default maximum HP
	zombie_damage = 10;						// Damage taken per zombie's bite
	
	stage = NULL;
	player = new Player;
	player->HP = playerHP;
	player->HP_Max = playerHP;
	dsp.set_player(player);
	zombieA = new Enemy(zombie_damage);
	zombieB = new Enemy(zombie_damage);
	
	select = NULL;
	temp = NULL;
	start = NULL;
	goal = NULL;
	
	INV.hammer = 0;							
	INV.water = 0;
	INV.bread = 0;
	INV.keys = 0;
	INV.bread_HP = 45;						// Amount of HP receovered from using Bread
	INV.water_HP = 15;						// Amount of HP receovered from using Water
	maxItem = 3;							// Max capacity of Container per item type
	dsp.set_inv(&INV);
}

/****************************
*							*
*		Main Gameflow		*
*							*
****************************/

void Game::run()
{
	bool done = false;
	bool took_damage = false;
	char replay = 'Y';
	bool dead = false;
	bool play = false;
	
	play = promptPlay();
	while (play)
	{
		dsp.instruction();										// Display instruction
		while (!done)
		{
			while (!dead)
			{
				level ++;										// New level
				setup();										// Setup a new SpaceList (2D Space Map)
				while (!stage_clear && !dead)					// While player is not dead and hasn't reached the goal
				{
					dsp.print(stage, dimension, dimension);		// Print the map
					dead = hasHP();								// Sets dead to true if life checker detected 0 HP
					if (!dead)									// If not dead, run action prompt and update status
					{
						act();									// prompt action and validate
						update();								// update stats and conditions, including enemies'
					}
					else
					{
						dsp.gameover();							// if player is dead, print gameover message
					}
				}
				cleanup();										// Whether clear stage or dead, do clean the Space map
				if(stage_clear)									// if stage clear, ask if player wants to continue or quit
				{
					play = promptContinue();
					if (!play)
						return;
				}
			}
			
			cout << endl;
			
			if (dead)
			{
				replay = val.qYN("--------- [?] Restart? Enter [Y] or [N] : --------- ");	// Prompt restart
				if (replay == 'N')
				{
					done = true;								// Quit game
					play = false;
					return;
				}
				else 
				{
					reset();									// Reset all stats
					dead = false;
				}
			}
		}
	}
}

/***********************
*					   *
*	  	Menu		   *
*				       *
***********************/

bool Game::promptPlay()
{
	cout << endl << endl
		<< "  This program is a Rouge-like Survival game." << endl
		<< "  Get to the goal to Win each Level." << endl 
		<< "  1. Play  " << endl
		<< "  2. Exit  " << endl;
		
	int i = val.qRI("> Enter [1] or [2] : " , 1, 2);

	if (i == 1)
	{
		return true;
	}

	return false;
}

bool Game::promptContinue()
{
	cout << endl << endl
		<< "  You won this level. Continue to next level?  " << endl 
		<< "  1. Continue  " << endl
		<< "  2. Exit  " << endl;
		
	int i = val.qRI("> Enter [1] or [2] : " , 1, 2);

	if (i == 1)
	{
		return true;
	}

	return false;
}



/***********************
*					   *
*	  	Setup 		   *
*				       *
***********************/

void Game::setup()
{
	// Reset stage clear flag
	stage_clear = false;
	
	// Create new map
	stage = mapper.map(dimension, player, zombieA, zombieB);
	
	// Reset goal
	goal = stage[1]->select(dimension);
}


/*******************************
*							   *
*		Detectors			   *
*						       *
*******************************/
bool Game::hasHP()
{				
	if (player->HP <1)
	{
		return true;
	}
	return false;
}


/***************************************
*							           *
*		Player Action Procesure		   *
*							           *
***************************************/

void Game::act()
{
	int r = player->row;
	int c = player->col;
	
	/*----------------------------
		Controller GUI
	----------------------------*/
	
		cout << "[O]Level : < " << level << " >" << endl;
		cout << "[+]Health Points : [ " << player->HP << " / " << player->HP_Max << " ]"  << endl;
		
		/*----------------------------
			Prompts action options
		----------------------------*/
			Space * target = (stage[r]->select(c))->action();
			string next_act = (stage[r]->select(c))->check_space(target);
			Space * make = NULL;
	
	/*------------------------------------------------------
	
		Rule: Player cannot walk into
		- Wall			(use Wall::bust() instead)
		- Gate			(use key to unlock instead)
		- Edge			(confirmed in Space::action())
		- Enemy			(confirmed in Space::action())	
	
	-------------------------------------------------------*/
	
	/*------------------------------------------------------
	
		Dynamic operation depending on:
			> player's decision 
			> player's current Space
			> player's surrounding Spaces
			> player's inventory item
	
	-------------------------------------------------------*/
	
	if (target == NULL)											// if target has been set to NULL, this action does not change location
	{		
		if (next_act == "Key")
		{
			dsp.key();
		}
		else if (next_act == "Bread")
		{
			if (INV.bread < 1)
				dsp.no_bread();
			else
				eat("BREAD");
		}
		else if (next_act == "Water")
		{
			if (INV.water < 1)
				dsp.no_water();
			else
				eat("WATER");
		}
		else if (next_act == "Hammer")
		{
			dsp.hammer();
		}

		target = stage[r]->select(c);							// Set the current space as the next target, means not moving anywhere this step
	}
	else 
	{
		if (target->get_type() == "GATE")						// This step is to unlock a Gate
		{
			if (INV.keys > 0)									// If inventory has a key
			{
				INV.keys --;									// Use key
				make = new Clear(-1, NULL, NULL, NULL, NULL);	// Make a clear block
				stage[1]-> replace (target, make);				// Replace Gate block with a clear block, so that player can move into
			}
			else 
			{
				dsp.no_key();
			}
		}
		else if (target->get_type() == "WALL")
		{
			Wall* wallPtr = static_cast<Wall*>(target);
			if (INV.hammer > 0)
			{
				dsp.prompt_hammer();
				
				char use_hammer = val.qYN("[Y] or [N]");
				
				if (use_hammer == 'Y')
				{
					INV.hammer --;
					wallPtr -> bust(3);
				}
				else 
				{
					wallPtr -> bust(1);
				}
			}
			else 
			{
				wallPtr -> bust(1);
			}
			
			if (wallPtr-> get_HP() <= 0)
			{
				int type_choice = dice.roll(1,10);
				if (type_choice == 1)
					make = new Bread (-1, NULL, NULL, NULL, NULL);
				else if (type_choice == 2)
					make = new Water (-1, NULL, NULL, NULL, NULL);
				else if (type_choice == 3)
					make = new Key (-1, NULL, NULL, NULL, NULL);
				else if (type_choice == 3)
					make = new Hammer (-1, NULL, NULL, NULL, NULL);
				else
					make = new Clear(-1, NULL, NULL, NULL, NULL);
				
				make->set_player(false);
				make->set_enemy(false);
				
				stage[1]-> replace (target, make);	
			}
			player->HP--;							// Reduce HP by 1 every attempt to break a wall		
		}
		else 										// It is certain that the direction is fine to walk into
		{
			(stage[r]->select(c))->set_player(false);
			if (next_act == "Go up")
			{
				player->row --;
			}
			else if (next_act == "Go left")
			{
				player->col --;
			}
			else if (next_act == "Go down")
			{
				player->row ++;
			}
			else if (next_act == "Go right")
			{
				player->col ++;
			}

			target->set_player(true);
			player->HP--;							// Reduce HP by 1 every step
		}
	}
}


/***************************************
*							           *
*		Auto Update Procedures         *
*							           *
***************************************/

void Game::update()
{
	bool picked;
	Space * player_location = stage[player->row]->select(player->col);
	string item = player_location->get_type();
	goal = stage[1]->select(dimension);
	
	/*-----------------------------------------------
	
		If player has reached Goal (top right), 
			display message,
			auto level change after update
		Else
			check if there's an item to pick up,
			and update enemy, check for damage
	
	-----------------------------------------------*/

	if (player_location == goal)
	{
		dsp.level_complete();
		stage_clear = true;
	}
	else
	{
		if (item != "CLEAR")
		{
			/*----------------------------------------------
			
				An item has been picked up. 
				Now Print the equivalent information, 
				and / or prompt immediate action.
			
			----------------------------------------------*/
			
			picked = pickup(item);		// Auto picks up the item regardless
			
			/*---------------------------------------------------
				If pickedup = true, 
					then inventory had space to carry
					item has been added to the inventory
					item is added even if using immediately
					if player chooses to consume now
					inventory would remove one
				Else
					for that item, inventory is full.
			----------------------------------------------------*/
			
			item_handler(picked, item);
		}
		
		/*----------------------------------------------
			After handling item pickup and immediate actions
			Run zombie action updates,
			and then print the updated map, 
			followed by damage report if any.
		----------------------------------------------*/
		
		enemy_handler();
	}
}


void Game::item_handler(bool picked, string item)
{
	int decision = 0;
	int r = player->row;
	int c = player->col;	
	Space* here = stage[r]->select(c);
	Space* make = NULL;
	
	
	if (picked)
	{

		if (item == "BREAD")					// If its Bread, there's an option
		{
			dsp.got_bread();
			
			decision = val.qRI("[?] Enter [1] to put away or [2] to eat now : " ,1 ,2 );
			
			if (decision == 2)
			{
				eat(item);
			}
		}
		else if (item == "WATER")				// If its Water, there's an option
		{
			dsp.got_water();
			
			decision = val.qRI("[?] Enter [1] to put away or [2] to drink now : " ,1 ,2 );
			
			if (decision == 2)
			{
				eat(item);
			}
		}
		else if (item == "HAMMER")				
		{
			dsp.got_hammer();
		}
		else if (item == "KEY")				
		{
			dsp.got_key();
		}			
	
		/*----------------------------------------------
		
			The item block is now replaced by a clear 
			block, and sets it as the player block,
			as player now occupised there.
		
		----------------------------------------------*/
		
		make = new Clear(-1, NULL, NULL, NULL, NULL);
		stage[r]->replace(here, make);
		(stage[r]->select(c))-> set_player(true);
	}
	else
	{
		/*----------------------------------------------
			The inventory is full.
		----------------------------------------------*/
		dsp.full();
	}				
	
}


void Game::enemy_handler()
{
	bool A_atk = enemy_update(zombieA);
	bool B_atk = enemy_update(zombieB);
	
	if (A_atk || B_atk)
	dsp.print(stage, dimension, dimension);

	if (A_atk)	
		dsp.attacked(zombieA);
	if (B_atk)	
		dsp.attacked(zombieB);
}



/**************************
*		     	          *
*		Mechanics         *
*						  *
**************************/


void Game::eat(string item)
{
	if (item == "BREAD")
	{
		player->HP += INV.bread_HP;
		INV.bread --;
		dsp.recover(INV. bread_HP);
	}
	else if (item == "WATER")
	{
		player->HP +=INV.water_HP;
		INV.water --;
		dsp.recover(INV.water_HP);
	}
	
	if (player->HP > player->HP_Max)
	{
		player->HP = player->HP_Max;
	}
	
	dsp.show_HP();
	
	hold();
}


int Game:: enemy_update(Enemy * E)
{
	bool in_range = false;
	int y_offset = 0;
	int x_offset = 0;
	
	/*-------------------------------------
		check if move is true or false
	--------------------------------------*/
	if (E->moved == true)							// If the enemy moved last round, then skip this round
	{
		E->moved = false;
	}
	else if (E->moved == false)
	{
		
		// make a move 
		while (E->moved == false)
		{
			y_offset = E->row - player->row;
			if (y_offset < 0)
				y_offset *= -1;
			
			x_offset = E->col - player->col;
			if (x_offset < 0)
				x_offset *= -1;		
			
			if ( y_offset > x_offset )				// if the vertical difference is greater than horizontal difference
			{
				if (E->row > player->row)
				{
					E->moved = enemy_move(E, "UP");
				}
				else if (E->row < player->row)
				{
					E->moved = enemy_move(E, "DOWN");
				}	
			}				
			else									// else if the horizontal difference is greater than vertical difference, OR the same as far
			{
				if (E->col > player->col)
				{
					E->moved = enemy_move(E, "LEFT");
				}
				else if (E->col < player->col)
				{
					E->moved = enemy_move(E, "RIGHT");
				}
				else
				{
					E->moved = true;
				}
			}

		}
		// attack if player is within range
		in_range = enemy_target(E);
		if (in_range)
		{
			player->HP -= zombie_damage;
			return 1;
		}
	}
	return 0;
}


bool Game::enemy_move(Enemy* E, string D)			//A.I logic to decide where to go. If Enemy is stuck, then stays there.
{
	int r = E->row;
	int c = E->col;
	Space * here = stage[r]->select(c);
	bool decided = false;
	string T = " ";
	int attempts = 0;

	here->set_enemy(false);
	while (decided == false && attempts < 4)
	{
		if (D == "UP")
		{
			T = (here->up)->get_type();
			if ( T == "CLEAR")
			{ 
				if ((here->up)->has_player() == false && (here->up)->has_enemy() == false)
				{
					E->row --;
					decided = true;
				}
				else
				{
					// Stay where he is
					decided = true;
				}
			}
			else
			{
				if (E->col <= player->col && attempts == 0)
					D = "RIGHT";
				else			
					D = "LEFT";	
				
				attempts ++;
			}
		}
		else if (D == "LEFT")
		{
			T = (here->left)->get_type();
			if ( T == "CLEAR")
			{ 
				if ((here->left)->has_player() == false && (here->left)->has_enemy() == false)
				{
					E->col --;
					decided = true;
				}
				else
				{
					// Stay where he is
					decided = true;
				}
			}
			else
			{
				if (E->row >= player->row && attempts == 0)
					D = "UP";
				else			
					D = "DOWN";
				attempts ++;
			}
		}
		else if (D == "DOWN")
		{
			T = (here->down)->get_type();
			if ( T == "CLEAR")
			{ 
				if ((here->down)->has_player() == false && (here->down)->has_enemy() == false)
				{
					E->row ++;
					decided = true;
				}
				else
				{
					// Stay where he is
					decided = true;
				}
			}
			else
			{
				if (E->col >= player->col && attempts == 0)
					D = "LEFT";
				else			
					D = "RIGHT";		
				attempts ++;
			}
		}
		else if (D == "RIGHT")
		{
			T = (here->right)->get_type();
			if ( T == "CLEAR")
			{ 
				if ((here->right)->has_player() == false && (here->right)->has_enemy() == false)
				{
					E->col ++;
					decided = true;
				}
				else
				{
					// Stay where he is
					decided = true;
				}
			}
			else
			{
				if (E->row <= player->row && attempts == 0)
					D = "DOWN";
				else			
					D = "UP";	
				
				attempts ++;
			}
		}
		else
		{
			cout << "Enemy is confused" << endl;
		}
		
	}
	// Stay where he is
	decided = true;
	here = stage[E->row]->select(E->col);
	here->set_enemy(true);
	
	return decided;
}


bool Game::enemy_target(Enemy* E)
{
	int r = E->row -1;
	int c = E->col -1;
	
	for (int x = 0; x < 3; x++)
	{
		for (int y = 0; y < 3; y++)
		{
			if((stage[r+y]->select(c+x))->has_player())
			{
				return true;
			}
		}
	}
	return false;
	
}


bool Game::pickup(string item) 
{
	if (item == "BREAD")
	{
		if (INV.bread < maxItem)
			INV.bread++;
	}
	else if (item == "WATER")
	{
		if (INV.water < maxItem)
			INV.water++;
	}
	else if (item == "KEY")
	{
		if (INV.keys < maxItem)
			INV.keys++;
	}
	else if (item == "HAMMER")
	{
		if (INV.hammer < maxItem)
			INV.hammer++;
	}
	else
	{
		cout << "Error: Picked up unknown item!" << endl;
	}
}




/*******************************
*							   *
*		Post-process		   *
*							   *
*******************************/

void Game::reset()
{
	player->HP = player->HP_Max;
	level = 0;
	stage_clear = false;
	INV.keys = 0;
	INV.bread = 0;
	INV.water = 0;
	INV.hammer = 0;
	select = NULL;
	temp = NULL;
	start = NULL;
	goal = NULL;

}


void Game::cleanup()
{
	mapper.set_null();
	stage = NULL;
}

void Game::hold()
{
	dsp.hold();
}

void Game::hold(string S)
{
	dsp.hold(S);
}

Game::~Game()
{
	if (stage != NULL)
	{
		cleanup();
	}
	delete player;
	player = NULL;
	delete zombieA;
	delete zombieB;
	zombieA = NULL;
	zombieB = NULL;
	select = NULL;
	temp = NULL;
	start = NULL;
	goal = NULL;
	
}
	
